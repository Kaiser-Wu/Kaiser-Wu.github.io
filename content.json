{"meta":{"title":"Kaiser.Wu","subtitle":null,"description":null,"author":"Kaiser.Wu","url":"https://kaiser-wu.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-02-26T11:59:54.401Z","updated":"2019-02-26T09:04:57.912Z","comments":false,"path":"/404.html","permalink":"https://kaiser-wu.github.io//404.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-02-26T11:59:54.455Z","updated":"2019-02-26T09:04:57.914Z","comments":true,"path":"links/index.html","permalink":"https://kaiser-wu.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-02-26T11:59:54.415Z","updated":"2019-02-26T09:04:57.913Z","comments":false,"path":"about/index.html","permalink":"https://kaiser-wu.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2019-02-26T11:59:54.442Z","updated":"2019-02-26T09:04:57.914Z","comments":false,"path":"categories/index.html","permalink":"https://kaiser-wu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-02-26T11:59:54.468Z","updated":"2019-02-26T09:04:57.914Z","comments":false,"path":"repository/index.html","permalink":"https://kaiser-wu.github.io/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-02-26T11:59:54.428Z","updated":"2019-02-26T09:04:57.913Z","comments":false,"path":"books/index.html","permalink":"https://kaiser-wu.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-26T11:59:54.483Z","updated":"2019-02-26T09:04:57.914Z","comments":false,"path":"tags/index.html","permalink":"https://kaiser-wu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 常用数据结构","slug":"Java 数据结构","date":"2019-02-28T04:03:49.591Z","updated":"2019-03-05T08:21:53.350Z","comments":true,"path":"2019/02/28/Java 数据结构/","link":"","permalink":"https://kaiser-wu.github.io/2019/02/28/Java 数据结构/","excerpt":"","text":"关于 Java 常用数据结构知识点分析和总结！ 总览UML 类图","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://kaiser-wu.github.io/categories/Java基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://kaiser-wu.github.io/tags/数据结构/"}]},{"title":"备忘录","slug":"备忘记录","date":"2019-02-27T01:33:03.807Z","updated":"2019-03-05T08:25:58.051Z","comments":true,"path":"2019/02/27/备忘记录/","link":"","permalink":"https://kaiser-wu.github.io/2019/02/27/备忘记录/","excerpt":"","text":"代办事项 MySQL MySQL 基本数据类型 建表数据类型的选取 索引的创建 Java XX","categories":[{"name":"备忘录","slug":"备忘录","permalink":"https://kaiser-wu.github.io/categories/备忘录/"}],"tags":[{"name":"备忘录","slug":"备忘录","permalink":"https://kaiser-wu.github.io/tags/备忘录/"}]},{"title":"MySQL 知识点总结","slug":"MySQL 知识点总结","date":"2019-02-26T12:15:35.279Z","updated":"2019-03-05T08:20:26.609Z","comments":true,"path":"2019/02/26/MySQL 知识点总结/","link":"","permalink":"https://kaiser-wu.github.io/2019/02/26/MySQL 知识点总结/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"https://kaiser-wu.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://kaiser-wu.github.io/tags/MySQL/"}]},{"title":"LombokProject","slug":"LombokProject","date":"2018-10-22T16:11:18.000Z","updated":"2019-03-05T09:09:19.336Z","comments":true,"path":"2018/10/23/LombokProject/","link":"","permalink":"https://kaiser-wu.github.io/2018/10/23/LombokProject/","excerpt":"","text":"一、简介Project Lombok是一个java库，它可以自动插入你的编辑器并构建工具，为你的java加油。永远不要再写另一个getter或equals方法。尽早访问未来的Java功能val，等等。 使用Project Lombok减少Boilerplate代码 “Boilerplate”是一个术语，用于描述在应用程序的许多部分中重复的代码，几乎没有任何改动。对Java语言最常提出批评的批评之一是大多数项目中都存在此类代码的数量。这个问题经常是各种库中设计决策的结果，但是由于语言本身的限制而加剧。龙目岛计划旨在通过一组简单的注释取代一些最严重的罪犯，以减少他们的流行程度。 虽然注释用于指示用法，实现绑定甚至生成框架使用的代码并不罕见，但它们通常不用于生成应用程序直接使用的代码。部分原因是这样做需要在开发时急切地处理注释。龙目岛计划正是这样做的。通过集成到IDE中，Project Lombok能够注入开发人员可立即使用的代码。例如，只需将@Data注释添加到数据类（如下所示），就会在IDE中生成许多新方法： 二、安装Project Lombok 项目在项目站点上作为单个jar文件提供 。它包括用于IDE开发的API作为IDE集成的安装程序。在大多数系统上，只需双击jar文件即可启动安装程序。如果系统未配置为正确启动jar文件，则还可以从命令行运行，如下所示： 1java -jar lombok.jar 安装程序将尝试检测支持的IDE的位置。如果无法正确确定IDE的安装位置，则可以手动指定位置。只需单击“安装/更新”，IDE集成即可完成。在撰写本文时，仅支持Eclipse和NetBeans。但是，IntelliJ IDEA源代码的发布使得IDEA支持成为未来版本的可能性，JDeveloper已经报告了有限的成功。 jar文件仍然需要包含在将使用Project Lombok注释的任何项目的类路径中。通过将此项目添加到项目pom.xml文件中，Maven用户可以将Lombok作为依赖项包括在内： 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt; org.projectlombok &lt;/ groupId&gt; &lt;artifactId&gt; lombok &lt;/ artifactId&gt; &lt;version&gt; 0.9.2 &lt;/ version&gt; &lt;/ dependency&gt; &lt;/ dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id &gt; projectlombok.org &lt;/ id&gt; &lt;url&gt; http://projectlombok.org/mavenrepo &lt;/ url&gt; &lt;/ repository&gt; &lt;/ repositories&gt; 三、Lombok 注释典型的Java项目将数百行代码用于定义简单数据类所需的样板文件并不罕见。这些类通常包含这些字段的若干字段，getter和setter，以及equals和 hashCode实施方式。在最简单的场景中，Project Lombok可以将这些类减少到必需的字段和单个@Data注释。 当然，最简单的场景不一定是开发人员日常所面临的场景。出于这个原因，Project Lombok中有许多注释允许对类的结构和行为进行更细粒度的控制。 3.1 @Getter和@Setter@Getter和@Setter注解分别产生一个字段的获取和设置。生成的getter正确遵循boolean属性的约定，从而产生 isFoogetter方法名称而不是getFoo 任何boolean字段foo。应当注意，如果注释字段所属的类包含与要生成的getter或setter同名的方法，则无论参数或返回类型如何，都不会生成相应的方法。 两个@Getter和@Setter注释一个可选参数，来指定所生成的方法的访问级别。 Lombok注释代码： 12@Getter @Setter private boolean employ = true; @Setter（AccessLevel.PROTECTED）private String name; 等效的Java源代码： 1234567891011121314private boolean employed = true;private String name;public boolean isEmployed() &#123; return employed;&#125;public void setEmployed(final boolean employed) &#123; this.employed = employed;&#125;protected void setName(final String name) &#123; this.name = name;&#125; 3.2 @NonNull@NonNull注释用于指示快速失败的相应部件空检查的需要。当放置在Lombok生成setter方法的字段上时，将生成空检查，这将导致NullPointerException 应该提供null值。此外，如果Lombok为拥有类生成构造函数，则该字段将添加到构造函数签名中，并且null检查将包含在生成的构造函数代码中。 此注释反映了在IntelliJ IDEA和FindBugs等中找到的@NotNull和@NonNull注释。 对于主题的这些变化，Lombok是注释不可知的。 如果Lombok遇到任何使用@NotNull或@NonNull名称注释注释的成员，它将通过生成适当的相应代码来表示它。 Project Lombok的作者进一步评论说，如果将此类型的注释添加到Java，则Lombok版本将被删除。 Lombok 注释的类 Family: 12@Getter @Setter @NonNullprivate List&lt;Person&gt; members; 等效的 Java 源码: 1234567891011121314151617@NonNullprivate List&lt;Person&gt; members;public Family(@NonNull final List&lt;Person&gt; members) &#123; if (members == null) throw new java.lang.NullPointerException(\"members\"); this.members = members;&#125; @NonNullpublic List&lt;Person&gt; getMembers() &#123; return members;&#125;public void setMembers(@NonNull final List&lt;Person&gt; members) &#123; if (members == null) throw new java.lang.NullPointerException(\"members\"); this.members = members;&#125; 3.3 @ToString此批注生成toString方法的实现。 默认情况下，任何非静态字段都将以名称 - 值对的形式包含在方法的输出中。 如果需要，可以通过将注释参数includeFieldNames设置为false来抑制输出中包含属性名称。 通过在exclude参数中包含其字段名称，可以从生成的方法的输出中排除特定字段。 或者，of参数可用于仅列出输出中所需的那些字段。 通过将callSuper参数设置为true，还可以包含超类的toString方法的输出。 Lombok 注释的代码 123456@ToString(callSuper=true,exclude=\"someExcludedField\")public class Foo extends Bar &#123; private boolean someBoolean = true; private String someStringField; private float someExcludedField;&#125; 等效的 Java 源码123456789101112public class Foo extends Bar &#123; private boolean someBoolean = true; private String someStringField; private float someExcludedField; @java.lang.Override public java.lang.String toString() &#123; return \"Foo(super=\" + super.toString() + \", someBoolean=\" + someBoolean + \", someStringField=\" + someStringField + \")\"; &#125;&#125; 3.4 @EqualsAndHashCode此类级别注释将导致Lombok生成equals和hashCode方法，因为这两者通过hashCode契约本质地绑定在一起。 默认情况下，两个方法都将考虑类中非静态或瞬态的任何字段。 与@ToString非常相似，提供了exclude参数以防止字段包含在生成的逻辑中。 也可以使用of参数列出应该考虑的那些字段。 也像@ToString一样，这个注释有一个callSuper参数。将其设置为true将导致equals通过在考虑当前类中的字段之前调用来自超类的equals来验证相等性。对于hashCode方法，它导致在计算哈希时结合超类的hashCode的结果。将callSuper设置为true时，请注意确保父类中的equals方法正确处理实例类型检查。如果父类检查该类是否属于特定类型而不仅仅是两个对象的类相同，则可能导致不希望的结果。如果超类使用Lombok生成的equals方法，则这不是问题。但是，其他实现可能无法正确处理此情况。另请注意，当类仅扩展Object时，无法将callSuper设置为true，因为这会导致实例等式检查使字段比较短路。这是由于生成的方法调用Object上的equals实现，如果被比较的两个实例不是同一个实例，则返回false。因此，在这种情况下，Lombok将生成编译时错误。 Lombok 注释的代码 12345678910111213@EqualsAndHashCode(callSuper=true,exclude=&#123;\"address\",\"city\",\"state\",\"zip\"&#125;)public class Person extends SentientBeing &#123; enum Gender &#123; Male, Female &#125; @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip;&#125; 等效的 Java 源码 12345678910111213141516171819202122232425262728293031323334353637383940public class Person extends SentientBeing &#123; enum Gender &#123; /*public static final*/ Male /* = new Gender() */, /*public static final*/ Female /* = new Gender() */; &#125; @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; if (!super.equals(o)) return false; final Person other = (Person)o; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false; if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + super.hashCode(); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode()); result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode()); return result; &#125;&#125; 3.5 @Data@Data注释可能是Project Lombok工具集中最常用的注释。 它结合了@ToString，@ EqualsAndHashCode，@ Getter和@Setter的功能。 本质上，在类上使用@Data与使用默认的@ToString和@EqualsAndHashCode注释类以及使用@Getter和@Setter注释每个字段相同。 使用@Data注释类也会触发Lombok的构造函数生成。 这会添加一个公共构造函数，它将任何@NonNull或final字段作为参数。 这提供了普通旧Java对象（POJO）所需的一切。 虽然@Data非常有用，但它不提供与其他Lombok注释相同的控制粒度。 要覆盖默认方法生成行为，请使用其他Lombok注释之一注释类，字段或方法，并指定必要的参数值以实现所需的效果。 @Data确实提供了一个可用于生成静态工厂方法的参数选项。 将staticConstructor参数的值设置为所需的方法名称将导致Lombok将生成的构造函数设置为private，并公开给定名称的静态工厂方法。 Lombok 注释的代码 123456@Data(staticConstructor=\"of\")public class Company &#123; private final Person founder; private String name; private List&lt;Person&gt; employees;&#125; 等效的 Java 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Company &#123; private final Person founder; private String name; private List&lt;Person&gt; employees; private Company(final Person founder) &#123; this.founder = founder; &#125; public static Company of(final Person founder) &#123; return new Company(founder); &#125; public Person getFounder() &#123; return founder; &#125; public String getName() &#123; return name; &#125; public void setName(final String name) &#123; this.name = name; &#125; public List&lt;Person&gt; getEmployees() &#123; return employees; &#125; public void setEmployees(final List&lt;Person&gt; employees) &#123; this.employees = employees; &#125; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; final Company other = (Company)o; if (this.founder == null ? other.founder != null : !this.founder.equals(other.founder)) return false; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.employees == null ? other.employees != null : !this.employees.equals(other.employees)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + (this.founder == null ? 0 : this.founder.hashCode()); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.employees == null ? 0 : this.employees.hashCode()); return result; &#125; @java.lang.Override public java.lang.String toString() &#123; return \"Company(founder=\" + founder + \", name=\" + name + \", employees=\" + employees + \")\"; &#125;&#125; 3.6 @Cleanup@Cleanup注释可用于确保释放已分配的资源。 当使用@Cleanup注释局部变量时，任何后续代码都包装在try / finally块中，该块保证在当前作用域的末尾调用cleanup方法。 默认情况下，@ Cleanan假定清理方法命名为“close”，与输入和输出流一样。 但是，可以为注释的value参数提供不同的方法名称。 只有不带参数的清理方法才能与此注释一起使用。 使用@Cleanup注释时还需要注意一点。 如果清理方法抛出异常，它将抢占方法体中引发的任何异常。 这可能导致问题的实际原因被掩盖，并且在选择使用Project Lombok的资源管理时应该考虑到这一点。 此外，随着Java 7中的自动资源管理，这个特定的注释可能相对短暂。 Lombok 注释的代码 123456789public void testCleanUp() &#123; try &#123; @Cleanup ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write(new byte[] &#123;'Y','e','s'&#125;); System.out.println(baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 等效的 Java 源码 12345678910111213public void testCleanUp() &#123; try &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try &#123; baos.write(new byte[]&#123;'Y', 'e', 's'&#125;); System.out.println(baos.toString()); &#125; finally &#123; baos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 3.7 @Synchronized在方法上使用synchronized关键字会导致不幸的影响，因为任何从事过多线程软件工作的开发人员都可以证明这一点。 对于静态方法，synchronized关键字将在实例方法的情况下锁定当前对象（this）或在类对象上锁定。 这意味着开发人员控制之外的代码可能会锁定同一个对象，从而导致死锁。 通常建议明确地锁定一个单独的对象，该对象仅专用于该目的，而不是以允许未经请求的锁定的方式公开。 Project Lombok为此目的提供了@Synchronized注释。 使用@Synchronized注释实例方法将提示Lombok生成一个名为$ lock的私有锁定字段，该方法将在执行之前锁定该字段。 类似地，以相同方式注释静态方法将生成名为$ LOCK的私有静态对象，以便以相同的方式使用静态方法。 可以通过为注释的value参数提供字段名称来指定不同的锁定对象。 提供字段名称时，开发人员必须定义属性，因为Lombok不会生成它。 Lombok 注释的代码 123456private DateFormat format = new SimpleDateFormat(\"MM-dd-YYYY\");@Synchronizedpublic String synchronizedFormat(Date date) &#123; return format.format(date);&#125; 等效的 Java 源码 12345678private final java.lang.Object $lock = new java.lang.Object[0];private DateFormat format = new SimpleDateFormat(\"MM-dd-YYYY\");public String synchronizedFormat(Date date) &#123; synchronized ($lock) &#123; return format.format(date); &#125;&#125; 3.8 @SneakyThrows@SneakyThrows可能是具有最多批评者的Project Lombok注释，因为它是对已检查异常的直接攻击。 关于使用已检查异常的问题存在很多分歧，大量开发人员认为这是一个失败的实验。 这些开发人员会喜欢@SneakyThrows。 在已检查/未检查的异常栏的另一侧的那些开发人员很可能将此视为隐藏潜在问题。 如果IllegalAccessException或某些父类未在throws子句中列出，则抛出IllegalAccessException通常会生成“未处理的异常”错误： 使用@SneakyThrows注释时，错误消失了。 默认情况下，@ SneakyThrows将允许抛出任何已检查的异常而不在throws子句中声明。 通过向注释的value参数提供可抛出类（Class &lt;？extends Throwable&gt;）的数组，可以将此限制为特定的异常集。 Lombok 注释的代码 1234@SneakyThrowspublic void testSneakyThrows() &#123; throw new IllegalAccessException();&#125; 等效的 Java 源码 1234567public void testSneakyThrows() &#123; try &#123; throw new IllegalAccessException(); &#125; catch (java.lang.Throwable $ex) &#123; throw lombok.Lombok.sneakyThrow($ex); &#125;&#125; 查看上面的代码和Lombok.sneakyThrow（Throwable）的签名将导致大多数人认为异常被包装在RuntimeException中并重新抛出，但事实并非如此。 sneakyThrow方法永远不会正常返回，而是将提供的throwable完全保持不变。 四、成本和收益与任何技术选择一样，使用Project Lombok也会产生正面和负面影响。 将Lombok的注释合并到项目中可以大大减少在IDE中生成或手工编写的样板代码行数。 这样可以减少维护开销，减少错误并提高可读性。 这并不是说在项目中使用Project Lombok注释没有缺点。 Lombok项目主要旨在填补Java语言的空白。 因此，可能会发生对语言的更改，从而妨碍使用Lombok的注释，例如添加第一类属性支持。 此外，当与基于注释的对象关系映射（ORM）框架结合使用时，数据类上的注释数量可能开始变得难以处理。 这在很大程度上被Lombok注释取代的代码量所抵消。 但是，那些避免经常使用注释的人可能会选择另一种方式。 4.1 什么消失了Lombok 注释的代码 123456789101112131415161718192021222324package com.ociweb.jnb.lombok;import java.util.Date;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.NonNull;@Data@EqualsAndHashCode(exclude=&#123;\"address\",\"city\",\"state\",\"zip\"&#125;)public class Person &#123; enum Gender &#123; Male, Female &#125; @NonNull private String firstName; @NonNull private String lastName; @NonNull private final Gender gender; @NonNull private final Date dateOfBirth; private String ssn; private String address; private String city; private String state; private String zip;&#125; 等效的 Java 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167package com.ociweb.jnb.lombok;import java.util.Date;import lombok.NonNull;public class Person &#123; enum Gender &#123; /*public static final*/ Male /* = new Gender() */, /*public static final*/ Female /* = new Gender() */; &#125; @NonNull private String firstName; @NonNull private String lastName; @NonNull private final Gender gender; @NonNull private final Date dateOfBirth; private String ssn; private String address; private String city; private String state; private String zip; public Person(@NonNull final String firstName, @NonNull final String lastName, @NonNull final Gender gender, @NonNull final Date dateOfBirth) &#123; if (firstName == null) throw new java.lang.NullPointerException(\"firstName\"); if (lastName == null) throw new java.lang.NullPointerException(\"lastName\"); if (gender == null) throw new java.lang.NullPointerException(\"gender\"); if (dateOfBirth == null) throw new java.lang.NullPointerException(\"dateOfBirth\"); this.firstName = firstName; this.lastName = lastName; this.gender = gender; this.dateOfBirth = dateOfBirth; &#125; @NonNull public String getFirstName() &#123; return firstName; &#125; public void setFirstName(@NonNull final String firstName) &#123; if (firstName == null) throw new java.lang.NullPointerException(\"firstName\"); this.firstName = firstName; &#125; @NonNull public String getLastName() &#123; return lastName; &#125; public void setLastName(@NonNull final String lastName) &#123; if (lastName == null) throw new java.lang.NullPointerException(\"lastName\"); this.lastName = lastName; &#125; @NonNull public Gender getGender() &#123; return gender; &#125; @NonNull public Date getDateOfBirth() &#123; return dateOfBirth; &#125; public String getSsn() &#123; return ssn; &#125; public void setSsn(final String ssn) &#123; this.ssn = ssn; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(final String address) &#123; this.address = address; &#125; public String getCity() &#123; return city; &#125; public void setCity(final String city) &#123; this.city = city; &#125; public String getState() &#123; return state; &#125; public void setState(final String state) &#123; this.state = state; &#125; public String getZip() &#123; return zip; &#125; public void setZip(final String zip) &#123; this.zip = zip; &#125; @java.lang.Override public java.lang.String toString() &#123; return \"Person(firstName=\" + firstName + \", lastName=\" + lastName + \", gender=\" + gender + \", dateOfBirth=\" + dateOfBirth + \", ssn=\" + ssn + \", address=\" + address + \", city=\" + city + \", state=\" + state + \", zip=\" + zip + \")\"; &#125; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; final Person other = (Person)o; if (this.firstName == null ? other.firstName != null : !this.firstName.equals(other.firstName)) return false; if (this.lastName == null ? other.lastName != null : !this.lastName.equals(other.lastName)) return false; if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false; if (this.dateOfBirth == null ? other.dateOfBirth != null : !this.dateOfBirth.equals(other.dateOfBirth)) return false; if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + (this.firstName == null ? 0 : this.firstName.hashCode()); result = result * PRIME + (this.lastName == null ? 0 : this.lastName.hashCode()); result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode()); result = result * PRIME + (this.dateOfBirth == null ? 0 : this.dateOfBirth.hashCode()); result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode()); return result; &#125;&#125; 4.2 限制虽然Project Lombok做了一些戏剧性的事情来让开发人员的生活更轻松，但它有其局限性。 浏览问题列表将很快阐明目前的一些缺点，其中大部分都是次要的。 一个重要的问题是无法检测超类的构造函数。 这意味着如果超类没有默认构造函数，则任何子类都不能使用@Data注释而不显式编写构造函数来使用可用的超类构造函数。 由于Project Lombok尊重与要生成的方法名称匹配的任何方法，因此使用此方法可以克服其大多数功能缺陷。 五、添加Lombok到项目Maven 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.16&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Ivy 1&lt;dependency org=&quot;org.projectlombok&quot; name=&quot;lombok&quot; rev=&quot;1.16.16&quot; conf=&quot;build&quot; /&gt; SBT 1libraryDependencies += &quot;org.projectlombok&quot; % &quot;lombok&quot; % &quot;1.16.16&quot; GradleIf your gradle version is &gt;= 2.121compileOnly \"org.projectlombok:lombok:1.16.16\" If you use an older version you can still use the following: 1provided \"org.projectlombok:lombok:1.16.16\" NOTE:You’ll still need to download lombok, or doubleclick on the lombok.jar file downloaded by maven / ivy / gradle, to install lombok into your eclipse installation.下载 lombok.jar 六、APIPackages6.1 lombok该软件包包含作为lombok用户所需的所有注释和支持类 类 ConfigurationKeys Lombok 枚举 AccessLevel 注解 @AllArgsConstructor生成一个all-args构造函数。 * `@Builder` 构建器注释为带注释的类或包含带注释的成员的类创建所谓的“构建器”方面@Builder。 * `@Builder.Default` 注释的字段@Default必须具有初始化表达式; 如果在构建期间未明确设置，则将该表达式作为默认使用。 * `@Builder.ObtainVia` 放置一个字段（在@Builder类型的情况下）或参数（用于@Builder构造函数或静态方法）以指示lombok如何在给定实例的情况下获取该字段或参数的值; 这只是相关toBuilder的true。 * `@Cleanup` 通过调用close方法确保您注释的变量声明将被清除，无论发生什么。 * `@Data` 生成所有字段的getter，有用的toString方法，以及检查所有非瞬态字段的hashCode和equals实现。 * `@EqualsAndHashCode` 根据相关字段为所有对象继承的方法equals和hashCode方法生成实现。 * `@Generated` Lombok最终会自动将此注释添加到所有生成的构造函数，方法，字段和类型中。 * `@Getter` lombok构建一个标准的getter。 * `@NoArgsConstructor` 生成一个无参数构造函数。 * `@NonNull` 如果放在参数上，lombok将在方法/构造函数体的开头插入一个空检查，NullPointerException并将参数的名称作为消息抛出 。 * `@RequiredArgsConstructor` 生成带有必需参数的构造函数。 * `@Setter` 使lombok构建一个标准的setter。 * `@Singular` 单数注释与@Builder用于在集合的构建器中创建单个元素“添加”方法一起使用。 * `@SneakyThrows` @SneakyThrow将避免javac坚持要么捕获或抛出方法体中声明它们生成的语句的任何已检查异常。 * `@Synchronized` 几乎就像将&apos;synchronized&apos;关键字放在方法上一样，除非在私有内部对象上进行同步，因此不受您控制的其他代码不会通过锁定您自己的实例来干扰您的线程管理。 * `@ToString` 为toString所有对象继承的方法生成实现，包括打印相关字段的值。 * `@val` 使用val任何局部变量声明的类型（甚至在换每个语句），和类型将从初始化表达来推断。 * `@Value` 生成许多​​适合于表示不可变实体的类的代码。 6.2 lombok.experimental此软件包包含作为lombok用户所需的注释和支持类，适用于尚未作为第一类功能支持的所有功能。 Accessors 用于生成getter和setter的设置的容器。 Delegate ExtensionMethod FieldDefaults Helper NonFinal PackagePrivate Tolerate UtilityClass var Wither 6.3 lombok.extern.apachecommons CommonsLog 导致lombok生成记录器字段。 Package lombok.extern.apachecommons 注解类型 @CommonsLog 123@Retention(SOURCE)@Target(TYPE)public @interface CommonsLog 示例： 123@CommonsLog public class LogExample &#123; &#125; 将生成： 123public class LogExample &#123; private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class); &#125; 此注解对类和枚举有效。 6.4 lombok.extern.java Log 导致lombok生成记录器字段。 Package lombok.extern.java 注解类型 @Log 123@Retention(SOURCE)@Target(TYPE)public @interface Log 示例： 123@Logpublic class LogExample &#123;&#125; 将生成： 123public class LogExample &#123; private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName()); &#125; **此注解对类和枚举有效。** 6.5 lombok.extern.jbosslog JBossLog 导致lombok生成记录器字段。 Package lombok.extern.jbosslog 注解类型 @JBossLog 123@Retention(SOURCE)@Target(TYPE)public @interface JBossLog 示例： 123@JBossLog public class LogExample &#123; &#125; 将生成： 123public class LogExample &#123; private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class); &#125; 此注解对类和枚举有效。 6.6 lombok.extern.log4j Log4j 导致lombok生成记录器字段。 Package lombok.extern.log4j 注解类型 @Log4j 123@Retention(SOURCE)@Target(TYPE)public @interface Log4j 示例： 123@Log4j public class LogExample &#123; &#125; 将生成： 123public class LogExample &#123; private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class); &#125; 此注解对类和枚举有效。 Log4j2 导致lombok生成记录器字段。 Package lombok.extern.log4j 注解类型 @Log4j2 123@Retention(SOURCE)@Target(TYPE)public @interface Log4j2 示例： 123@Log4j2public class LogExample &#123;&#125; 将生成： 123public class LogExample &#123; private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class); &#125; 此注解对类和枚举有效。 6.7 lombok.extern.slf4j Slf4j 导致lombok生成记录器字段。 Package lombok.extern.slf4j 注解类型 `@Slf4j` 123@Retention(SOURCE)@Target(TYPE)public @interface Slf4j 示例： 123@Slf4j public class LogExample &#123; &#125; 将生成： 123public class LogExample &#123; private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);&#125; **此注解对类和枚举有效。** XSlf4j 导致lombok生成记录器字段。 Package lombok.extern.slf4j 注解类型 `@XSlf4j` 123@Retention(SOURCE)@Target(TYPE)public @interface XSlf4j 示例： 123@XSlf4j public class LogExample &#123; &#125; 将生成： 123 public class LogExample &#123; private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);&#125; **此注解对类和枚举有效。** ##七、常用注解 val var @NonNull @Cleanup @Getter/@Setter @ToString @EqualsAndHashCode @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor @Data @Value @Builder @SneakyThrows @Synchronized @Getter(lazy=true) @Log","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://kaiser-wu.github.io/categories/效率工具/"}],"tags":[{"name":"lombok","slug":"lombok","permalink":"https://kaiser-wu.github.io/tags/lombok/"}]}]}